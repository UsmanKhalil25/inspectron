import logging
from typing import List
from playwright.async_api import Page, Response

from vulnerability_scanner.schemas import Vulnerability
from vulnerability_scanner.types import VulnerabilitySeverity


class SecurityHeadersScanner:

    SECURITY_HEADERS = {
        "Content-Security-Policy": {
            "severity": VulnerabilitySeverity.HIGH,
            "description": "Content-Security-Policy (CSP) header is missing. This header helps prevent XSS attacks by controlling which resources can be loaded.",
            "recommendation": "Add a Content-Security-Policy header with appropriate directives for your application.",
        },
        "X-Frame-Options": {
            "severity": VulnerabilitySeverity.MEDIUM,
            "description": "X-Frame-Options header is missing. This header protects against clickjacking attacks.",
            "recommendation": "Add X-Frame-Options header with value 'DENY' or 'SAMEORIGIN'.",
        },
        "X-Content-Type-Options": {
            "severity": VulnerabilitySeverity.MEDIUM,
            "description": "X-Content-Type-Options header is missing. This header prevents MIME type sniffing.",
            "recommendation": "Add X-Content-Type-Options header with value 'nosniff'.",
        },
        "Strict-Transport-Security": {
            "severity": VulnerabilitySeverity.HIGH,
            "description": "Strict-Transport-Security (HSTS) header is missing. This header enforces secure HTTPS connections.",
            "recommendation": "Add Strict-Transport-Security header with value 'max-age=31536000; includeSubDomains'.",
        },
        "Referrer-Policy": {
            "severity": VulnerabilitySeverity.LOW,
            "description": "Referrer-Policy header is missing. This header controls how much referrer information is shared.",
            "recommendation": "Add Referrer-Policy header with an appropriate value like 'strict-origin-when-cross-origin'.",
        },
    }

    def __init__(self):
        self.logger = logging.getLogger(__name__)

    async def scan(self, page: Page, url: str) -> List[Vulnerability]:
        vulnerabilities = []

        try:
            response = await self._get_response(page)
            if not response:
                self.logger.warning("No response available for URL %s", url)
                return vulnerabilities

            headers = response.headers

            for header_name, header_info in self.SECURITY_HEADERS.items():
                if not self._has_header(headers, header_name):
                    vulnerability = Vulnerability(
                        url=url,
                        scanner="SecurityHeadersScanner",
                        severity=header_info["severity"],
                        title=f"Missing {header_name} header",
                        description=header_info["description"],
                        recommendation=header_info["recommendation"],
                    )
                    vulnerabilities.append(vulnerability)
                    self.logger.info("Found vulnerability: %s", vulnerability)

        except Exception as e:
            self.logger.exception(
                "Error scanning security headers for %s: %s", url, str(e)
            )

        return vulnerabilities

    async def _get_response(self, page: Page) -> Response | None:
        try:
            response = await page.goto(page.url)
            return response
        except Exception:
            return None

    def _has_header(self, headers: dict, header_name: str) -> bool:
        header_name_lower = header_name.lower()
        return any(key.lower() == header_name_lower for key in headers.keys())

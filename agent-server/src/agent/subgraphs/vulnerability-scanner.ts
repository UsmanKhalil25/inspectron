import { StateGraph } from "@langchain/langgraph";
import {
  Vulnerability,
  VulnerabilityScanState,
  VulnerabilityScanStateSchema,
} from "../types/vulnerability";
import { BrowserFactory } from "../factory";
import { Page } from "playwright";

// Security headers to check
const SECURITY_HEADERS = {
  "content-security-policy": {
    severity: "high" as const,
    title: "Missing Content-Security-Policy Header",
    description:
      "The Content-Security-Policy (CSP) header is not set, which leaves the application vulnerable to XSS attacks.",
    recommendation:
      "Implement a Content-Security-Policy header to restrict resource loading and prevent XSS attacks.",
  },
  "strict-transport-security": {
    severity: "high" as const,
    title: "Missing Strict-Transport-Security Header",
    description:
      "The Strict-Transport-Security (HSTS) header is not set, which may allow man-in-the-middle attacks.",
    recommendation:
      "Add the Strict-Transport-Security header to enforce HTTPS connections.",
  },
  "x-frame-options": {
    severity: "medium" as const,
    title: "Missing X-Frame-Options Header",
    description:
      "The X-Frame-Options header is not set, which may allow clickjacking attacks.",
    recommendation:
      "Set X-Frame-Options to 'DENY' or 'SAMEORIGIN' to prevent clickjacking.",
  },
  "x-content-type-options": {
    severity: "medium" as const,
    title: "Missing X-Content-Type-Options Header",
    description:
      "The X-Content-Type-Options header is not set, which may allow MIME-type sniffing attacks.",
    recommendation:
      "Set X-Content-Type-Options to 'nosniff' to prevent MIME-type sniffing.",
  },
  "referrer-policy": {
    severity: "low" as const,
    title: "Missing Referrer-Policy Header",
    description:
      "The Referrer-Policy header is not set, which may leak sensitive information in the referrer.",
    recommendation:
      "Set Referrer-Policy to control how much referrer information is shared.",
  },
};

// Patterns for detecting exposed secrets
const SECRET_PATTERNS = [
  {
    name: "AWS Access Key",
    pattern: /AKIA[0-9A-Z]{16}/g,
    severity: "critical" as const,
  },
  {
    name: "AWS Secret Key",
    pattern: /aws_secret_access_key\s*=\s*['"]([^'"]+)['"]/gi,
    severity: "critical" as const,
  },
  {
    name: "GitHub Token",
    pattern: /ghp_[a-zA-Z0-9]{36}/g,
    severity: "critical" as const,
  },
  {
    name: "Generic API Key",
    pattern: /api[_-]?key\s*[:=]\s*['"]([a-zA-Z0-9_\-]{20,})['"]/gi,
    severity: "high" as const,
  },
  {
    name: "Private Key",
    pattern: /-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----/g,
    severity: "critical" as const,
  },
  {
    name: "JWT Token",
    pattern: /eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*/g,
    severity: "medium" as const,
  },
  {
    name: "Database Connection String",
    pattern:
      /(mongodb|mysql|postgresql|postgres):\/\/[^\s<>"{}|\\^`[\]]+/gi,
    severity: "critical" as const,
  },
];

// Capture page data from Playwright
async function capturePageDataNode(
  state: VulnerabilityScanState
): Promise<Partial<VulnerabilityScanState>> {
  const page = await BrowserFactory.getPage();

  if (!page) {
    console.log("[Vulnerability Scanner] No active page found");
    return { scanComplete: true, vulnerabilities: [] };
  }

  try {
    // Get page source
    const pageSource = await page.content();

    // Get response headers from the main document
    const responseHeaders = await page.evaluate(() => {
      const headers: Record<string, string> = {};
      const performance = (window as any).performance;
      const navEntries = performance.getEntriesByType("navigation");

      if (navEntries && navEntries.length > 0) {
        const navEntry = navEntries[0] as any;
        if (navEntry.serverTiming) {
          // Headers aren't directly accessible via Performance API
          // We'll need to use a different approach
        }
      }

      return headers;
    });

    // Get cookies
    const cookies = await page.context().cookies();

    // Get actual response headers using CDP (Chrome DevTools Protocol)
    let actualHeaders: Record<string, string> = {};
    try {
      const client = await page.context().newCDPSession(page);
      await client.send("Network.enable");

      // Get headers from the main document response
      const response = page.mainFrame().page().request;

      // For now, we'll get headers from the response object
      const mainResponse = await page.goto(page.url(), { waitUntil: "commit" });
      if (mainResponse) {
        actualHeaders = mainResponse.headers();
      }
    } catch (error) {
      console.log(
        "[Vulnerability Scanner] Could not get headers via CDP:",
        error
      );
      // Fallback: try to get headers from the page response
      try {
        const response = await page.request.get(page.url());
        actualHeaders = response.headers();
      } catch (fallbackError) {
        console.log(
          "[Vulnerability Scanner] Could not get headers via request:",
          fallbackError
        );
      }
    }

    const url = page.url();

    console.log(
      `[Vulnerability Scanner] Captured data for ${url}: ${pageSource.length} chars, ${Object.keys(actualHeaders).length} headers, ${cookies.length} cookies`
    );

    return {
      url,
      pageSource,
      responseHeaders: actualHeaders,
      cookies: cookies.map((c) => ({
        name: c.name,
        value: c.value,
        domain: c.domain,
        path: c.path,
        expires: c.expires,
        httpOnly: c.httpOnly,
        secure: c.secure,
        sameSite: c.sameSite as "Strict" | "Lax" | "None" | undefined,
      })),
    };
  } catch (error) {
    console.error("[Vulnerability Scanner] Error capturing page data:", error);
    return { scanComplete: true, vulnerabilities: [] };
  }
}

// Scan for missing or weak security headers
async function scanHeadersNode(
  state: VulnerabilityScanState
): Promise<Partial<VulnerabilityScanState>> {
  const vulnerabilities: Vulnerability[] = [];
  const headers = state.responseHeaders || {};

  // Normalize header keys to lowercase for case-insensitive comparison
  const normalizedHeaders: Record<string, string> = {};
  Object.keys(headers).forEach((key) => {
    normalizedHeaders[key.toLowerCase()] = headers[key];
  });

  // Check for missing security headers
  Object.entries(SECURITY_HEADERS).forEach(([headerName, config]) => {
    if (!normalizedHeaders[headerName]) {
      vulnerabilities.push({
        id: `header-${headerName}-missing`,
        type: "missing_header",
        severity: config.severity,
        title: config.title,
        description: config.description,
        recommendation: config.recommendation,
        location: "HTTP Response Headers",
      });
    }
  });

  // Check for weak CSP if present
  const csp = normalizedHeaders["content-security-policy"];
  if (csp) {
    if (csp.includes("unsafe-inline") || csp.includes("unsafe-eval")) {
      vulnerabilities.push({
        id: "header-csp-weak",
        type: "weak_header",
        severity: "medium",
        title: "Weak Content-Security-Policy",
        description:
          "The CSP header contains 'unsafe-inline' or 'unsafe-eval' directives, which weaken XSS protection.",
        recommendation:
          "Remove 'unsafe-inline' and 'unsafe-eval' from CSP directives. Use nonces or hashes for inline scripts.",
        location: "Content-Security-Policy header",
        evidence: csp,
      });
    }
  }

  console.log(
    `[Vulnerability Scanner] Found ${vulnerabilities.length} header vulnerabilities`
  );

  return {
    vulnerabilities: [...(state.vulnerabilities || []), ...vulnerabilities],
  };
}

// Scan for insecure cookies
async function scanCookiesNode(
  state: VulnerabilityScanState
): Promise<Partial<VulnerabilityScanState>> {
  const vulnerabilities: Vulnerability[] = [];
  const cookies = state.cookies || [];
  const isHttps = state.url.startsWith("https://");

  cookies.forEach((cookie) => {
    const issues: string[] = [];

    // Check for missing Secure flag on HTTPS sites
    if (isHttps && !cookie.secure) {
      issues.push("missing Secure flag");
    }

    // Check for missing HttpOnly flag (except for specific cookies that need JS access)
    if (!cookie.httpOnly && !cookie.name.match(/^(csrf|xsrf)/i)) {
      issues.push("missing HttpOnly flag");
    }

    // Check for missing SameSite attribute
    if (!cookie.sameSite) {
      issues.push("missing SameSite attribute");
    }

    if (issues.length > 0) {
      let severity: "low" | "medium" | "high" | "critical" = "low";
      if (issues.includes("missing Secure flag")) {
        severity = "medium";
      }
      if (issues.includes("missing HttpOnly flag")) {
        severity = "medium";
      }
      if (
        issues.includes("missing Secure flag") &&
        issues.includes("missing HttpOnly flag")
      ) {
        severity = "high";
      }

      vulnerabilities.push({
        id: `cookie-${cookie.name}-insecure`,
        type: "insecure_cookie",
        severity,
        title: `Insecure Cookie: ${cookie.name}`,
        description: `Cookie '${cookie.name}' has security issues: ${issues.join(", ")}.`,
        recommendation: `Set the following attributes on the cookie: ${
          issues.includes("missing Secure flag") ? "Secure; " : ""
        }${issues.includes("missing HttpOnly flag") ? "HttpOnly; " : ""}${
          issues.includes("missing SameSite attribute")
            ? "SameSite=Strict or SameSite=Lax"
            : ""
        }`,
        location: `Cookie: ${cookie.name}`,
        evidence: `Domain: ${cookie.domain}, Path: ${cookie.path}`,
      });
    }
  });

  console.log(
    `[Vulnerability Scanner] Found ${vulnerabilities.length} cookie vulnerabilities`
  );

  return {
    vulnerabilities: [...(state.vulnerabilities || []), ...vulnerabilities],
  };
}

// Scan for exposed secrets in page source
async function scanSecretsNode(
  state: VulnerabilityScanState
): Promise<Partial<VulnerabilityScanState>> {
  const vulnerabilities: Vulnerability[] = [];
  const pageSource = state.pageSource || "";

  SECRET_PATTERNS.forEach((pattern) => {
    const matches = pageSource.matchAll(pattern.pattern);
    const matchArray = Array.from(matches);

    if (matchArray.length > 0) {
      matchArray.forEach((match, index) => {
        // Get context around the match (30 chars before and after)
        const matchIndex = match.index || 0;
        const contextStart = Math.max(0, matchIndex - 30);
        const contextEnd = Math.min(pageSource.length, matchIndex + 100);
        const context = pageSource.substring(contextStart, contextEnd);

        vulnerabilities.push({
          id: `secret-${pattern.name.toLowerCase().replace(/\s+/g, "-")}-${index}`,
          type: "exposed_secret",
          severity: pattern.severity,
          title: `Exposed ${pattern.name}`,
          description: `A ${pattern.name} was found in the page source, which could be exploited if accessed by an attacker.`,
          recommendation: `Remove the ${pattern.name} from client-side code. Store secrets securely on the server and use environment variables.`,
          location: "Page Source",
          evidence: `...${context.replace(/</g, "&lt;").replace(/>/g, "&gt;")}...`,
        });
      });
    }
  });

  console.log(
    `[Vulnerability Scanner] Found ${vulnerabilities.length} exposed secrets`
  );

  return {
    vulnerabilities: [...(state.vulnerabilities || []), ...vulnerabilities],
  };
}

// Aggregate results and calculate risk level
async function aggregateResultsNode(
  state: VulnerabilityScanState
): Promise<Partial<VulnerabilityScanState>> {
  const vulnerabilities = state.vulnerabilities || [];

  console.log(
    `[Vulnerability Scanner] Scan complete. Total vulnerabilities: ${vulnerabilities.length}`
  );

  return {
    vulnerabilities,
    scanComplete: true,
  };
}

// Create the vulnerability scanner workflow
const workflow = new StateGraph(VulnerabilityScanStateSchema)
  .addNode("capture_page_data", capturePageDataNode)
  .addNode("scan_headers", scanHeadersNode)
  .addNode("scan_cookies", scanCookiesNode)
  .addNode("scan_secrets", scanSecretsNode)
  .addNode("aggregate_results", aggregateResultsNode)
  .addEdge("__start__", "capture_page_data")
  .addEdge("capture_page_data", "scan_headers")
  .addEdge("scan_headers", "scan_cookies")
  .addEdge("scan_cookies", "scan_secrets")
  .addEdge("scan_secrets", "aggregate_results")
  .addEdge("aggregate_results", "__end__");

// Compile the graph without a checkpointer (it will inherit from parent)
export const vulnerabilityScannerGraph = workflow.compile();
